<!DOCTYPE html>
<html lang="en">
<head>
<title>JavaScript Implementation of Block TEA Tiny Encryption Algorithm (xxtea)</title>
<meta charset="utf-8">
<meta name="author" content="Chris Veness, www.movable-type.co.uk">
<meta name="keywords" content="block tiny encryption algorithm feistel cipher javascript">
<link rel="stylesheet" href="../css/mtl5.css">
<link rel="stylesheet" href="../css/prettify.css">
<style>
  pre { margin-left: 4em; max-width: 64em; padding: 1em; }
  pre.fullwidth { max-width: 72em; }
  pre.prettyprint { padding: 1em; } /* make general? */
</style>
<!--[if lte IE 7]>
<style type="text/css"> /* IE! sigh! */
  ul    { position: relative; top: 0.5em; }
  ul li { vertical-align: top; position: relative; top: -0.5em; }
  ul li { max-width: none; }
</style>
<![endif]-->
<script src="tea-block.js">/* Block TEA (xxtea) JavaScript implementation */</script>
<script src="base64.js">/* Base64 encoding */</script>
<script src="utf8.js">/* UTF-8 encoding */</script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="../js/mtl.js">/* MTL utils */</script>
<script src="../js/prettify.js">/* google-code-prettify */</script>
<script>
  $(document).ready(function() {
    prettyPrint();
  });

  String.prototype.debug = function() {
    var s='';
    for (var i=0; i<this.length; i++) s += this.charAt(i) + ':' + this.charCodeAt(i) + ' ';
    return this + ': ' + s;
  }
</script>
</head>

<body>
<div class="header"> <a href="../"><img src="../images/mtl.gif" alt="Movable Type Home Page" width="120" height="120"></a>
  <h1>Movable Type Scripts</h1>
  <hr>
  <h2>Block TEA (Tiny Encryption Algorithm)</h2>
</div>

<div id="content">
      <p>Wheeler & Needham’s <a href="http://www.cl.cam.ac.uk/ftp/papers/djw-rmn/djw-rmn-tea.html">Tiny 
        Encryption Algorithm</a> is a simple but powerful encryption algorithm 
        (based on a ‘Feistel cipher’). </p>
      <p>This is a JavaScript implementation of the (<a href="http://www.cl.cam.ac.uk/ftp/users/djw3/xxtea.ps">corrected</a>) 
        ‘<a href="http://www.cl.cam.ac.uk/ftp/users/djw3/xtea.ps">Block 
        TEA </a>’ or ‘large block’ version of the algorithm (also dubbed 
        ‘xxtea’) which operates on variable-sized blocks, as opposed to the 64-bit 
        blocks of the original.</p>
      <p>This is a simple but highly effective DES-style encryption algorithm 
        which can be useful for web applications which require security 
        or encryption. It provides very secure cryptographically strong 
        encryption in concise, clear JavaScript code.</p>
      <form name="f">
      <fieldset><legend>Functional demo</legend>
        <table>
          <tr> 
            <td>Password:</td>
            <td><input type="text" name="password" value="encryptioñ-pw" class="w12"></td>
          </tr>
          <tr> 
            <td>Plaintext:</td>
            <td><textarea name="plaintxt" class="w48">søme highly secret text to be encrypteđ</textarea></td>
          </tr>
          <tr> 
            <td><button type="button"
              onClick='f.encrypted.value = Tea.encrypt(f.plaintxt.value, f.password.value)'>Encrypt it:</button></td>
            <td><textarea name="encrypted" class="w48"></textarea></td>
          </tr>
          <tr> 
            <td><button type="button"
              onClick='f.decrypted.value = Tea.decrypt(f.encrypted.value, f.password.value)'>Decrypt it:</button></td>
            <td><textarea name="decrypted" class="w48"></textarea></td>
          </tr>
        </table>
      </fieldset>
  </form>
      <p>The Block TEA version is faster than the original (64-bit block version) when encrypting longer 
        blocks (over 16 chars), and is more secure (‘a single bit change will change about one half of 
        the bits of the entire block, leaving no place where the changes start’). It is also simpler to 
        implement in JavaScript for encrypting arbitrary-length texts (being variable block size, it requires 
        no ‘mode of operation’). For an implementation of the original algorithm, see <a href="tea.html">tea.html</a>.</p>
      <p>TEA uses a 128-bit key, which could (for increased security) be an encrypted (or hashed) form of the 
        supplied password. Here I simply convert the first 16 characters of the password into longs to 
        generate the key. The password might be a user-supplied password, or an internal system password. 
        A system password will be more secure if it avoids plain-text (e.g. ‘dVr4t%G§Uu+mz7+8’).</p>
      <p><a href="http://www.cl.cam.ac.uk/misc/obituaries/wheeler/">Wheeler</a> &amp; <a href="http://www.cl.cam.ac.uk/misc/obituaries/needham/">Needham</a>’s original formulation (in C) of corrected block TEA (aka xxtea) was
        as follows:</p>
      <pre class="prettyprint">#define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z);

long btea(long* v, long n, long* k) {
  unsigned long z=v[n-1], y=v[0], sum=0, e, DELTA=0x9e3779b9;
  long m, p, q ;
  if (n &gt; 1) {          /* Coding Part */
    q = 6+52/n ;
    while (q-- &gt; 0) {
      sum += DELTA;
      e = sum &gt;&gt; 2&amp;3 ;
      for (p=0; p&lt;n-1; p++) y = v[p+1], z = v[p] += MX;
      y = v[0];
      z = v[n-1] += MX;
    }
    return 0 ; 
  } else if (n &lt; -1) {  /* Decoding Part */
    n = -n ;
    q = 6+52/n ;
    sum = q*DELTA ;
    while (sum != 0) {
      e = sum&gt;&gt;2 &amp; 3;
      for (p=n-1; p&gt;0; p--) z = v[p-1], y = v[p] -= MX;
      z = v[n-1];
      y = v[0] -= MX;
      sum -= DELTA;
    }
    return 0;
  }
  return 1;
}</pre>
      <p>I needed to encrypt text, not binary data, so I have built on this so that it operates on text
        rather than just on numeric arrays, and also rearranged
        it slightly so that <i>p</i> is
        not referenced outside the <i>for</i> loop (valid in C, but not always in other languages). The
        ciphertext is encoded as Base64 so that it can be safely stored and/or transmitted without troublesome
        control characters causing problems. The plaintext is first converted to UTF-8 so that the script
        is multi-byte-character safe.</p>
      <p><i>Speed:</i> using IE on a 3GHz P4 the script processes around 80kB/sec (around 25 pages of
        text), though it slows down with longer texts.</p>
  <p id='otherLang'><i>In other languages:</i> remember <b><i>always</i></b> to use either <i><b>unsigned
          right-shift</b> operators</i> or unsigned  type declarations, according to features available in the language – signed
        right shift operations  will fail; also, in strToLongs(), to avoid running off the end of the
        string, some languages may  need the string to be padded to a multiple of 4 characters, with
        the equivalent of <span class="code">for 
        (var p=0; p&lt;3-(s.length-1)%4; p++) s += '\0';</span>.</p>
      <p>For an explanation of the operation of the TEA algorithm, and cryptography in general, an excellent 
        book is <i>Information Security Intelligence: Cryptographic Principles &amp; Applications</i> 
        by Tom Calabrese (available from <a href="http://www.amazon.com/exec/obidos/tg/detail/-/1401837271/">Amazon.com</a>). 
        There is also a good article explaining <a href="http://www-users.cs.york.ac.uk/~matthew/TEA/">TEA 
        operation and cryptanalysis</a> by Matthew Russell from York University and a short article in 
        <a href="http://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm">Wikipedia</a>.</p>
      <p id='versions'>Note: if you are interested in cryptanalysis of TEA, bear in mind that there are
        4 versions described  in 3 documents: the original <i><a href="tea.pdf" target="_blank">TEA</a></i>,
        then <i><a href="xtea.pdf" target="_blank">Extensions to TEA</a></i> (addressing
        weaknesses  in TEA and also describing Block TEA), and <i><a href="xxtea.pdf" target="_blank">Corrections
        to Block TEA</a></i> (aka xxtea).
        This page implements the last of these. </p>
      <p>If you want industrial-strength encryption, I have also implemented a version of <a href="aes.html">AES</a>.</p>
      <p>For some security applications, a cryptographic hash is more appropriate than encryption – if 
        you are interested in a hash function, see my implementation of <a href="sha1.html">SHA-1</a>.</p>
  <hr class="fullwidth">
  <p>See
    below for the source code of the JavaScript implementation. </p>
  <p id="licence"><a href="http://creativecommons.org/licenses/by/3.0/" style="float:right"><img alt="Creative Commons License" style="margin:4px" src="http://i.creativecommons.org/l/by/3.0/88x31.png"></a>I
    offer these formulæ &amp; scripts for free use and adaptation as my
    contribution to the open-source info-sphere from which I have received so much. You are welcome to
    re-use these scripts [under a simple <a href="http://creativecommons.org/licenses/by/3.0/">attribution</a> license,
    without any warranty express or implied] provided solely that you retain my copyright notice and
    a link to this page.</p>
  <p>If you would like to show your appreciation, I would most gratefully accept <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" title="Thank you!">donations</a>.</p>
  <p><i>Note</i>: this script was <b>revised</b> in <b>October 2009</b> to handle multi-byte characters
    by means of <b>UTF-8
    encoding</b> and to use <b>Base64
      encoding</b> for the ciphertext –
    the previous version used a less standard encoding which can still be seen on the <a href="tea.html">TEA</a> page.
    I also adapted it to use JavaScript <a href="namespaces.html">namespaces</a> in place of conventional
    function names.</p>
  <p>If you have any queries or find any problems, contact me at <span class="rtl">ku.oc.epyt-elbavom@cne-stpircs</span>.</p>
  <p class="note"><i>© 2005-2012 Chris Veness</i></p>
  <hr class="fullwidth">
  <pre class="fullwidth prettyprint" id="code">
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Block TEA (xxtea) Tiny Encryption Algorithm implementation in JavaScript                      */
/*     (c) Chris Veness 2002-2012: www.movable-type.co.uk/tea-block.html                          */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Algorithm: David Wheeler &amp; Roger Needham, Cambridge University Computer Lab                   */
/*             http://www.cl.cam.ac.uk/ftp/papers/djw-rmn/djw-rmn-tea.html (1994)                 */
/*             http://www.cl.cam.ac.uk/ftp/users/djw3/xtea.ps (1997)                              */
/*             http://www.cl.cam.ac.uk/ftp/users/djw3/xxtea.ps (1998)                             */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Tea = {};  // Tea namespace

/*
 * encrypt text using Corrected Block TEA (xxtea) algorithm
 *
 * @param {string} plaintext String to be encrypted (multi-byte safe)
 * @param {string} password  Password to be used for encryption (1st 16 chars)
 * @returns {string} encrypted text
 */
Tea.encrypt = function(plaintext, password) {
    if (plaintext.length == 0) return('');  // nothing to encrypt
    
    // convert string to array of longs after converting any multi-byte chars to UTF-8
    var v = Tea.strToLongs(Utf8.encode(plaintext));
    if (v.length &lt;= 1) v[1] = 0;  // algorithm doesn't work for n&lt;2 so fudge by adding a null
    // simply convert first 16 chars of password as key
    var k = Tea.strToLongs(Utf8.encode(password).slice(0,16));  
    var n = v.length;
    
    // ---- &lt;TEA coding&gt; ---- 
    
    var z = v[n-1], y = v[0], delta = 0x9E3779B9;
    var mx, e, q = Math.floor(6 + 52/n), sum = 0;
    
    while (q-- &gt; 0) {  // 6 + 52/n operations gives between 6 &amp; 32 mixes on each word
        sum += delta;
        e = sum&gt;&gt;&gt;2 &amp; 3;
        for (var p = 0; p &lt; n; p++) {
            y = v[(p+1)%n];
            mx = (z&gt;&gt;&gt;5 ^ y&lt;&lt;2) + (y&gt;&gt;&gt;3 ^ z&lt;&lt;4) ^ (sum^y) + (k[p&amp;3 ^ e] ^ z);
            z = v[p] += mx;
        }
    }
    
    // ---- &lt;/TEA&gt; ----
    
    var ciphertext = Tea.longsToStr(v);
    
    return Base64.encode(ciphertext);
}

/*
 * decrypt text using Corrected Block TEA (xxtea) algorithm
 *
 * @param {string} ciphertext String to be decrypted
 * @param {string} password   Password to be used for decryption (1st 16 chars)
 * @returns {string} decrypted text
 */
Tea.decrypt = function(ciphertext, password) {
    if (ciphertext.length == 0) return('');
    var v = Tea.strToLongs(Base64.decode(ciphertext));
    var k = Tea.strToLongs(Utf8.encode(password).slice(0,16)); 
    var n = v.length;
    
    // ---- &lt;TEA decoding&gt; ---- 
    
    var z = v[n-1], y = v[0], delta = 0x9E3779B9;
    var mx, e, q = Math.floor(6 + 52/n), sum = q*delta;

    while (sum != 0) {
        e = sum&gt;&gt;&gt;2 &amp; 3;
        for (var p = n-1; p &gt;= 0; p--) {
            z = v[p&gt;0 ? p-1 : n-1];
            mx = (z&gt;&gt;&gt;5 ^ y&lt;&lt;2) + (y&gt;&gt;&gt;3 ^ z&lt;&lt;4) ^ (sum^y) + (k[p&amp;3 ^ e] ^ z);
            y = v[p] -= mx;
        }
        sum -= delta;
    }
    
    // ---- &lt;/TEA&gt; ---- 
    
    var plaintext = Tea.longsToStr(v);

    // strip trailing null chars resulting from filling 4-char blocks:
    plaintext = plaintext.replace(/\0+$/,'');

    return Utf8.decode(plaintext);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

// supporting functions

Tea.strToLongs = function(s) {  // convert string to array of longs, each containing 4 chars
    // note chars must be within ISO-8859-1 (with Unicode code-point &lt; 256) to fit 4/long
    var l = new Array(Math.ceil(s.length/4));
    for (var i=0; i&lt;l.length; i++) {
        // note little-endian encoding - endianness is irrelevant as long as 
        // it is the same in longsToStr() 
        l[i] = s.charCodeAt(i*4) + (s.charCodeAt(i*4+1)&lt;&lt;8) + 
               (s.charCodeAt(i*4+2)&lt;&lt;16) + (s.charCodeAt(i*4+3)&lt;&lt;24);
    }
    return l;  // note running off the end of the string generates nulls since 
}              // bitwise operators treat NaN as 0

Tea.longsToStr = function(l) {  // convert array of longs back to string
    var a = new Array(l.length);
    for (var i=0; i&lt;l.length; i++) {
        a[i] = String.fromCharCode(l[i] &amp; 0xFF, l[i]&gt;&gt;&gt;8 &amp; 0xFF, 
                                   l[i]&gt;&gt;&gt;16 &amp; 0xFF, l[i]&gt;&gt;&gt;24 &amp; 0xFF);
    }
    return a.join('');  // use Array.join() rather than repeated string appends for efficiency in IE
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Base64 class: Base 64 encoding / decoding (c) Chris Veness 2002-2012                          */
/*    note: depends on Utf8 class                                                                 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Base64 = {};  // Base64 namespace

Base64.code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Encode string into Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
 * (instance method extending String object). As per RFC 4648, no newlines are added.
 *
 * @param {String} str The string to be encoded as base-64
 * @param {Boolean} [utf8encode=false] Flag to indicate whether str is Unicode string to be encoded 
 *   to UTF8 before conversion to base64; otherwise string is assumed to be 8-bit characters
 * @returns {String} Base64-encoded string
 */ 
Base64.encode = function(str, utf8encode) {  // http://tools.ietf.org/html/rfc4648
  utf8encode =  (typeof utf8encode == 'undefined') ? false : utf8encode;
  var o1, o2, o3, bits, h1, h2, h3, h4, e=[], pad = '', c, plain, coded;
  var b64 = Base64.code;
   
  plain = utf8encode ? Utf8.encode(str) : str;
  
  c = plain.length % 3;  // pad string to length of multiple of 3
  if (c &gt; 0) { while (c++ &lt; 3) { pad += '='; plain += '\0'; } }
  // note: doing padding here saves us doing special-case packing for trailing 1 or 2 chars
   
  for (c=0; c&lt;plain.length; c+=3) {  // pack three octets into four hexets
    o1 = plain.charCodeAt(c);
    o2 = plain.charCodeAt(c+1);
    o3 = plain.charCodeAt(c+2);
      
    bits = o1&lt;&lt;16 | o2&lt;&lt;8 | o3;
      
    h1 = bits&gt;&gt;18 &amp; 0x3f;
    h2 = bits&gt;&gt;12 &amp; 0x3f;
    h3 = bits&gt;&gt;6 &amp; 0x3f;
    h4 = bits &amp; 0x3f;

    // use hextets to index into code string
    e[c/3] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  }
  coded = e.join('');  // join() is far faster than repeated string concatenation in IE
  
  // replace 'A's from padded nulls with '='s
  coded = coded.slice(0, coded.length-pad.length) + pad;
   
  return coded;
}

/**
 * Decode string from Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
 * (instance method extending String object). As per RFC 4648, newlines are not catered for.
 *
 * @param {String} str The string to be decoded from base-64
 * @param {Boolean} [utf8decode=false] Flag to indicate whether str is Unicode string to be decoded 
 *   from UTF8 after conversion from base64
 * @returns {String} decoded string
 */ 
Base64.decode = function(str, utf8decode) {
  utf8decode =  (typeof utf8decode == 'undefined') ? false : utf8decode;
  var o1, o2, o3, h1, h2, h3, h4, bits, d=[], plain, coded;
  var b64 = Base64.code;

  coded = utf8decode ? Utf8.decode(str) : str;
  
  
  for (var c=0; c&lt;coded.length; c+=4) {  // unpack four hexets into three octets
    h1 = b64.indexOf(coded.charAt(c));
    h2 = b64.indexOf(coded.charAt(c+1));
    h3 = b64.indexOf(coded.charAt(c+2));
    h4 = b64.indexOf(coded.charAt(c+3));
      
    bits = h1&lt;&lt;18 | h2&lt;&lt;12 | h3&lt;&lt;6 | h4;
      
    o1 = bits&gt;&gt;&gt;16 &amp; 0xff;
    o2 = bits&gt;&gt;&gt;8 &amp; 0xff;
    o3 = bits &amp; 0xff;
    
    d[c/4] = String.fromCharCode(o1, o2, o3);
    // check for padding
    if (h4 == 0x40) d[c/4] = String.fromCharCode(o1, o2);
    if (h3 == 0x40) d[c/4] = String.fromCharCode(o1);
  }
  plain = d.join('');  // join() is far faster than repeated string concatenation in IE
   
  return utf8decode ? Utf8.decode(plain) : plain; 
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */
/*              single-byte character encoding (c) Chris Veness 2002-2012                         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Utf8 = {};  // Utf8 namespace

/**
 * Encode multi-byte Unicode string into utf-8 multiple single-byte characters 
 * (BMP / basic multilingual plane only)
 *
 * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars
 *
 * @param {String} strUni Unicode string to be encoded as UTF-8
 * @returns {String} encoded string
 */
Utf8.encode = function(strUni) {
  // use regular expressions &amp; String.replace callback function for better efficiency 
  // than procedural approaches
  var strUtf = strUni.replace(
      /[\u0080-\u07ff]/g,  // U+0080 - U+07FF =&gt; 2 bytes 110yyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0);
        return String.fromCharCode(0xc0 | cc&gt;&gt;6, 0x80 | cc&amp;0x3f); }
    );
  strUtf = strUtf.replace(
      /[\u0800-\uffff]/g,  // U+0800 - U+FFFF =&gt; 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0); 
        return String.fromCharCode(0xe0 | cc&gt;&gt;12, 0x80 | cc&gt;&gt;6&amp;0x3F, 0x80 | cc&amp;0x3f); }
    );
  return strUtf;
}

/**
 * Decode utf-8 encoded string back into multi-byte Unicode characters
 *
 * @param {String} strUtf UTF-8 string to be decoded back to Unicode
 * @returns {String} decoded string
 */
Utf8.decode = function(strUtf) {
  // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!
  var strUni = strUtf.replace(
      /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = ((c.charCodeAt(0)&amp;0x0f)&lt;&lt;12) | ((c.charCodeAt(1)&amp;0x3f)&lt;&lt;6) | ( c.charCodeAt(2)&amp;0x3f); 
        return String.fromCharCode(cc); }
    );
  strUni = strUni.replace(
      /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = (c.charCodeAt(0)&amp;0x1f)&lt;&lt;6 | c.charCodeAt(1)&amp;0x3f;
        return String.fromCharCode(cc); }
    );
  return strUni;
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
  </pre>
</div>

</body>
</html>
